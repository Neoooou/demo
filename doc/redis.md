# Redis
使用C语言开发的纯内存数据库，提供极快的数据存储和查询速度

# 1.数据结构
五种数据类型：String、List、Set、Hash、SortedSet

## String

没有使用C语言传统的字符串表示（以空字符串\0结尾的字符数组）， 基于SDS（Simple Dynamic String）实现

```c++
struct sdshdr{
//记录buff数组中已使用字节的数量 等于sds所保存字符串长度
int len;

/记录buff数组中未使用字节的数量
int free;

//字节数组，保存字符串
char buf[];
}
```

- 结构体保留了字符串长度，优化了**STRLEN**和**APPEND**性能，
- 保留数据中间空格\0, 支持存储二进制文件，例如音频、视频二进制数据
- 空间预分配，惰性空间释放，减少了内存重新分配
- 修改时，检查空间大小，不会造成缓冲区溢出

## List
ZipList
压缩列表，更加紧凑、占用空间更小的列表数据形式

## Hash

## Set

## Sorted Set (zset)
zrange
zadd
zscore
zrank

数据结构：dict + skipList
跳跃表，多层链表，原理简单，容易实现。每次插入有50%的概率增加一层，
插入、删除、查找都是O(log(n))的时间复杂度

相对红黑树：
- 插入、删除需要进行子树的调整，也就是左右子树平衡的过程
- 范围查找，需要进行中序遍历（左中右），耗时相对较长
对比Mysql B+树：
- B+树同时存储索引和数据文件，数据文件较大，不适合使用zset存储在缓存。

# 2. 核心原理
##  2.1 Redis速度快的原因
- 完全基于内存操作
- C语言实现，优化过的数据结构
- 使用单线程，无上下文切换成本
- 基于非阻塞的多路IO复用

## 2.2 主从同步

初次或者重新连接master时，进行全量同步，步骤如下：

1、slave -->master: psync
2、master执行bgsave生成rdb快照，同时将此之后的写命令记录到缓冲区（repl_baklog）
3、master发送rbd快照文件以及offset
4、slave接受快照文件，并将文件快照载入
5、slave接受这段时间缓冲区的命令，完成同步

repl_baklog是一个环形数组，写完之后就从零开始覆盖，如果slave发送的同步请求里的offset在环形数组不存在， 则进行全量同步，否则进行增量同步


## 2.3 数据过期策略

当redis中有数据过期了，如何处理

**被动过期** 只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期
key没有再次被访问，从而不会被清除，占用大量内存。

**主动过期** 每隔一定的时间，例如10s，从过期字典（设置了过期时间的key）随机挑选出一定量的key， 并清除其中已过期的key。该策略是前两者的一个折中方案。
通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。(expires字典会保存所有设置了过期时间的key的过期
时间数据，其中key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)

Redis同时使用了惰性过期和定期过期两种过期策略。但是Redis定期删除是随机抽取机制，不可能扫描删除掉所有的过期Key。因此需要内存淘汰机制。

## 2.4 内存淘汰策略

1. **LRU**least recently used 挑选最久未使用的数据淘汰， volatile-lru是redis的默认淘汰策略，在已过期的keys中，挑选最久未访问的keys淘汰
2. **LFU** 挑选最少使用的数据淘汰
3. **TTL** 挑选将要过期的数据淘汰
4. **RANDOM** 挑选任意的数据淘汰
5. **NO-ENVICTION** 不淘汰数据，新写入操作会报错, 默认策略

[volatile-lru|allkeys-lru|volatile-random|allkeys-random|volatile-ttl|volatile-lfu|allkeys-lfu|noeviction]

## 2.5 持久化
当Redis服务器意外宕机时，可直接从磁盘恢复宕机时数据，也可用于主从同步
### 2.5.1 RDB
Redis Database， save命令手动触发，或者bgSave在一个特定的间隔保存那个时间节点的数据快照 ，fork一个
子进程把数据写到一个临时的rdb文件，写完之后替换就得rdb文件

**优点**
- RDB是一个简洁的单文件，保存了某个时间节点的redis数据，很适合做备份，用于备灾，因为单文件很方便传输到远程服务器上
- RBD的性能很好，持久化时，会fork一个子进程，把持久化的工作交给子进程处理，自己不会进行IO操作
- 相对AOF，在数据量较大的情况下，RDB的启动速度更快

**缺点**

- RDB持久化容易造成数据的丢失，若在某个快照间隔内，redis不能正常工作，则上次快照到出问题这段时间的数据就会丢失
- 使用fork子进程进行数据的持久化，若数据量较大会造成redis停止服务几毫秒，若CPU性能不好，则会停止服务甚至一秒
- 实时性不够，没办法做到秒级

### 2.5.2 AOF
Append Of File， 文件追加式。当某个写入命令执行完成后，记录到日志文件，在服务器启动时，根据记录的操作日志逐条执行而重建出原来的数据


# 3. 集群架构
## 3.1 哨兵

## 3.2 代理集群
### 3.2.1 分片算法
**一致性哈希**
使用哈希函数将Keu映射到环状的Redis节点，当映射节点不均匀时，引入虚拟节点来平衡，当扩缩容时，只需要部分数据重新映射，降低迁移的开销

一致性哈希算法具有以下几个优点：
扩缩容时的数据迁移问题
均衡负载：一致性哈希算法能够将数据在节点上均匀分布，避免出现热点数据集中在某些节点上而导致负载不均衡的情况。通过增加虚拟节点的数量，可以进一步增强负载均衡的效果；
扩展性：在一致性哈希算法中，当节点数量增加或减少时，只有部分数据需要重新映射，系统能够进行水平扩展更容易，可以增加节点数量以应对更大的负载需求；
减少数据迁移：相比传统的哈希算法，一致性哈希算法在节点增减时需要重新映射的数据量较少，可以大幅降低数据迁移的开销，减少系统的不稳定性和延迟；
容错性：一致性哈希算法在节点故障时能够保持较好的容错性。当某个节点失效时，只有存储在该节点上的数据需要重新映射，这使得系统能够更好地应对节点故障，提高系统的可用性和稳定性；
简化管理：由于一致性哈希算法中节点的加入和离开对数据分片的影响较小，系统管理员进行节点的动态管理更加方便。节点的扩容和缩容操作对整个系统的影响相对较小，简化了系统的管理和维护过程

**哈希槽**
用哈希算法，将Key映射到16K个槽位，根据机器性能的不同，分配不同的槽位，性能较好分配更多的槽位。数据迁移时，直接将对应槽位的数据迁走，更方便
16k个槽位，节点间心跳通信时，使用BitMap，仅需2kb数据即可





# 4. 场景使用

## 4.1 常见问题
**热KEY**：突然有大量的请求去访问同一个key，导致流量过于集中，达到物理网卡的上限，打蹦这台redis服务器  
*解决*  
- 提前把热key的数据分散到不同的服务器
- 加入二级缓存，提前加载热key数据到本地缓存

**缓存击穿**：单个key的访问量过高，当key过期时，所有的请求打到db  
*解决*  
- 当key的数据不存在，加锁，同时去db查询数据后写入缓存，后续的访问则从缓存可以读取到数据
- 异步的方式不间断刷新缓存

**缓存穿透**：查询不存在缓存的key，每次请求都打到db，就像缓存不存在一样  
*解决*  
- 布隆过滤器，存入数据时，通过hash的方式映射一个组数中k点，查询数据时，若无映射点，直接返回。  
问题是存在误判，hash的过程导致很多值映射至同一个k点，产生误判

**缓存雪崩**：某一时刻，大规模的缓存失效，会有大量的请求打到DB  
*解决*
- 设置不同的过期时间，防止同时失效

## 4.2 对比memcached
**持久性**
Redis支持数据落地持久化，可以将内存中的数据保存在磁盘上，重启时可以再次加载使用
memcached不支持数据的持久化
**分布式存储**
redis支持master-slave复制模式
memcached可以使用一致性hash做分布式

**数据一致性不同**

Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于
Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。 redis使用的是单线程模型，保证了数据按顺序提交。

memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作 

## 4.3 缓存策略
**cache aside**： 旁路缓存，
写：先写db，然后删除缓存
读：读缓存，缓存没有数据，则读db，写入缓存，结果返回

优点：
写的时候，直接删除，而不是更新，避免大key的写入耗时带来的rt增加
读的时候懒加载，或者应用启动时拉取热点数据
适合大部分场景

存在不一致：
高并发时，
A： 写入
B:读取
C：写入
B:读取完成，写入缓存

保证强一致，未读到数据之后加锁，写入操作加锁，且是同一把锁


**writer behind**：直接写缓存，异步写db，适合高并发写入场景，例如秒杀

## 4.4 事务
watch 解决ABA问题 事务开启之前，观察一个或者多个key是否有被更改
multi
exec

# 4. Q&A
## 4.1 为什么使用单线程
Redis是基于内存的操作，作为IO密集型英语，CPU不是Redis的瓶颈，更多是机器内存的大小或者网络带宽带来的限制。采用单线程避免了不必要的线程上下文切换的损耗，
以及线程安全性问题。

## 4.2 为什么Redis6.0之后又改用多线程呢?
使用多线程是为了处理数据的读写和协议解析，执行命令依然是单线程，所有到达服务端的命令都是单线程负责执行的。





# Memcached

memcached只支持简单的数据类，复杂的对象需要自己处理

