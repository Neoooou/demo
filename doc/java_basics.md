# 多线程
一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。

## Java线程的声明周期

- New， 新创建的对象，还未调用start方法
- Runnable， 包含两种状态ready和running， 对象调用start方法后，线程处于ready状态，等待线程调度选中，分配CPU时间片，进入running运行状态
- Blocked，表示线程阻塞于锁
  - 等待阻塞：运行状态中执行wait()方法,使线程进入等待阻塞状态
  - 同步阻塞：线程获取synchronize同步锁失败
  - 其他阻塞：通过调用线程的Sleep()或Join发出I/O请求，线程就会进入到阻塞状态，当Sleep()状态超时，join()等待线程终止或超时，或者I/O处理完毕，线程就会进入就绪状态。
- 等待(WAITING):进入该状态的线程需要等待其他线程做出一些特定动作(通知或中断)。
- 超时等待(TIMED_WAITING):该状态不同于WAITING，它可以在指定的时间后自行返回。
- 终止(TERMINATED):表示该线程已经执行完毕

## 线程优先级

每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。
Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。
默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。
具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。

## 多线程并发执行需满足三大特性

- 原子性， 一个操作和多个操作要么全部执行，不被任何因素打断，要么全部不执行
- 可见性，多线程访问一个变量使，一个线程修改了变量的值，其他线程可以立即看到修改的值，volatile关键字保证了可见性
- 有序性，程序执行的顺序按照代码先后顺序执行

## volatile

- 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，这个新值对其他线程是可见的，
- 禁止指令重排

**使用场景** 对变量的写操作不依赖于变量的当前值， 例如状态标记，更新的状态值不依赖于当前的状态值

## 锁

### synchronized
关键字，将方法或者代码锁起来，保证多线程并发执行时对共享资源的安全访问，有序执行，一次只允许一个线程执行。synchronized通过操作对象头中的Mark Word实现锁的同步和线
程同步。
Java对象在内存中的存储结构：对象头、实例数据、对齐和填充
- 对象头：Mark Word（标记字）、类指针（指向类元数据在方法区的地址）、数组长度（如果对象是数组，会额外存储数组的长度）
- 实例数据：对象中的各种成员变量，包括基本和引用类型，基本类型存储内容，引用类型存储指针。静态变量在类中
- 对齐和填充：主要为了提高CPU内存访问速度

其中Mark Word(标记字)包括：
- Hashcode
- GC标记信息
- 锁状态标志（无锁、偏向锁、轻量级锁、重量级锁）
- 偏向线程ID和偏向时间戳（如果使用偏向锁）

**偏向锁**：当一个线程首次进入同步块时，JVM会给对象分配偏向锁。
**轻量级锁**：如果有另一个线程尝试获取锁，偏向锁会升级为轻量级锁。使用CAS操作实现，适用于低竞争场景，避免上下文切换
**重量级锁**：如果轻量级锁竞争激烈，锁会升级为重量级锁。使用操作系统互斥量实现，适用于高竞争场景，开销大。

**自旋操作**：当锁获取失败时，线程不会立马进入阻塞状态，而是循环自旋一段时间去获取锁，减少阻塞和唤醒的开销，适合等待时间较短的场景。长时间的自旋会导致
CPU资源的无谓浪费，所以一般设定最长自旋时间。

对象有自己的对象头，存储了很多信息，其中一个信息标示是被哪个线程持有**。它可以保证代码的**原子性**和**可见性**，线程在加锁时，
先清空工作内存---在主存中拷贝最新变量的副本到工作内存---执行完代码---将更改后的变量刷新到主存中---释放锁，

Java内存模型：

- 所有变量都存储在主内存中
- 每个线程都有独立的工作内存，里面保存的是该线程使用到的变量副本
- 对共享变量的所有操作都必须在自己的工作内存中完成，不能直接写在主存中
- 不同线程间不能相互访问工作内存，必须通过主内存完成

### Lock

显示锁，通过lock(),tryLock(),tryLock(long time, TimeUnit unit)和lockInterruptibily()来获取锁，unlock()方法来释放锁，tryLock会放回
boolean值，代表是否获取锁成功

### 锁的特性

- **可重入**，线程可以进入任何一个它所拥有的锁同步着的代码块，synchronized和ReentrantLock都是可重入锁。线程再次获取锁，只需判断该线程是否是拥
有该锁的线程即可，锁的最终释放：线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示 当
前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。

- **公平**：以请求锁的顺序来获取锁，同时有多个线程在等待一个琐时，当锁被释放时，等待时间最久的线程会优先获得锁，synchronized是非公平锁，对于
ReentrantLock和reentrantReadWriteLock,默认是非公平锁，但可设置为公平锁

- **读写**，将对同一资源的访问分成两个锁，读和写，保证同时可以有多个线程对同一资源进行读操作，ReadWriteLock就是读写锁，它是一个接口，ReentrantR
eadWriteLock实现了这个接口，可以通过readLock（）获取读锁，WriteLock获取写锁

- **可中断**，在等待锁的过程中允许中断的锁，例如线程A在获取了锁在执行某段代码，线程B在等待过程中，不想等待了可以处理其他代码业务，我们支持它中断自己
或者在其他线程中中断B的锁等待。Lock属于可中断锁，LockInterruptibly()方法体现了这一特点，synchronized属于不可中断锁。

- **乐观/悲观**，
乐观锁每次拿数据的时候会认为该数据不会被更改，所以不会上锁，**适用于多读的场景**，但是在更新的时候会判断数据是否被更改，一般使用**CAS**（Compare And Set）机制实现，
    CAS机制：

    1. 比较数据实际值与预期值是否相符，相符则进行更改操作，但是存在**ABA问题**，即预期值为A且实际值也为A，无法证明值为得到修改，例如栈里面栈顶元素与相邻元素相同，经过出栈操作后，栈顶元素依然不变；所以需要使用版本号，每次更改都会修改版本号，利用版本号来判断是否进行了修改操作。
    2. 如果`CAS`操作失败，就需要循环进行`CAS`操作(循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销。限制自旋次数，防止进入死循环
    3. `CAS`的原子操作只能针对一个共享变量。如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行`CAS`操作。

  - 悲观锁，每次拿数据的时候会认为该数据会被更改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）**，synchronized和lock关键字都是悲观锁思想。

- **互斥与自旋**
请求锁资源失败时，互斥锁会失败进入阻塞状态，失败CPU资源片。而自旋锁会进行空转，不会挂起，不停尝试获取锁资源，避免了锁短时间释放的CPU上下文切换。
### 分布式锁

在系统进行分布式部署时，多个节点对同一数据进行操作时，保证只有一个节点可以对共享资源进行操作，防止不同节点重复同样的工作，以及破坏数据正确性。

**特点**：

- 互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。

- 可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。

- 锁超时:和本地锁一样支持锁超时，防止死锁。

- 高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。

分布式锁的思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁

Redis分布式锁：在 Redis 中设置一个值表示加了锁，然后释放锁的时候就把这个 Key 删除

## BIO/NIO/AIO

- BIO（Blocking IO）同步阻塞式IO模式，数据的读写必须阻塞在一个线程内完成，线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。适用于连接数较少且固定的架构
- NIO（Non-blocking IO）同步非阻塞的IO模型，线程发起IO请求后，立即返回，不必原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区是否就绪，适用于连接数目较多且连接比较短的架构
- AIO（Asynchronous IO）异步非阻塞的IO模型，基于事件和回调机制实现，应用操作后会直接返回，不会堵塞在那里，当后台处理完成时，会通知相应的线程进行后续的操作