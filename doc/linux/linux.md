Linux内核：
宏内核：负责操作系统的所有最高权限，一切功能，包括：内存管理，进程调度，文件系统，设备驱动等.都由内核服务统一管理。执行链路短，效率高。

微内核：将某些功能下放都用户空间，比如设备驱动，划分为独立的用户进程，执行链路更长，效率低，但是易于扩展

# 1.虚拟内存

在现代操作系统中，多任务已是标配。多任务并行，大大提升了 CPU 利用率，但却引出了多个进程对内存操作的冲突问题，虚拟内存概念的提出就是为了解决这个问题。

为了充分利用和管理系统内存资源，Linux采用虚拟内存管理技术，利用虚拟内存技术让每个进程都有一片互不干涉的虚拟地址空间。进程初始化分配和管理都基于虚拟地址，只有当进程需要实际访问内存资源才会建立虚拟地址和物理地址的映射，调入物理内存页

## 1.1 分页和页表
page cache
系统里基本单位是byte，如果建立一个每个虚拟地址都映射到虚拟地址的表，每个地址都需要8个字节（32位虚拟地址->32位虚拟地址），那么4GB的物理内存就需要32GB的空间的映射表，这么大的表真正的物理地址也存储不了，所以引入了页的概念。
操作系统将内存以4k位大小进行页的划分，之后进行内存分配是，都是以页为单位，那么虚拟内存页对应物理内存页的映射表大小也就大大减少了，4GB的物理内存只需要8K的映射表即可。一些进程没有使用到的虚拟内存，也并不需要保存映射关系，而且Linux 还为大内存设计了多级页表，可以进一页减少了内存消耗。操作系统虚拟内存到物理内存的映射表，就被称为`页表`。

## 1.2 内存寻址和分配

我们知道通过虚拟内存机制，每个进程都以为自己占用了全部内存，进程访问内存时，操作系统都会把进程提供的虚拟内存地址转换为物理地址，再去对应的物理地址上获取数据。CPU 中有一种硬件，`内存管理单元 MMU（Memory Management Unit）`专门用来将翻译虚拟内存地址。CPU 还为页表寻址设置了缓存策略，由于程序的局部性，其缓存命中率能达到 98%。
以上情况是页表内存在虚拟地址到物理地址的映射，而如果进程访问的物理地址还没有被分配，系统则会产生一个`缺页中断`，在中断处理时，系统切到内核态为进程虚拟地址分配物理地址。
虚拟内存不仅通过内存地址转换解决了多个进程访问内存冲突的问题，还带来更多的益处。

## 1.3 进程内存管理

它有助于进程进行内存管理，主要体现在：

- 内存完整性：由于虚拟内存对进程的”欺骗”，每个进程都认为自己获取的内存是一块连续的地址。我们在编写应用程序时，就不用考虑大块地址的分配，总是认为系统有足够的大块内存即可。
- 安全：由于进程访问内存时，都要通过页表来寻址，操作系统在页表的各个项目上添加各种访问权限标识位，就可以实现内存的权限控制。

## 1.4 数据共享

通过虚拟内存更容易实现内存和数据的共享。
在进程加载系统库时，总是先分配一块内存，将磁盘中的库文件加载到这块内存中，在直接使用物理内存时，由于物理内存地址唯一，即使系统发现同一个库在系统内加载了两次，但每个进程指定的加载内存不一样，系统也无能为力。
而在使用虚拟内存时，系统只需要将进程的虚拟内存地址指向库文件所在的物理内存地址即可。如上文图中所示，进程 P1 和 P2 的 B 地址都指向了物理地址 C。
而通过使用虚拟内存使用共享内存也很简单，系统只需要将各个进程的虚拟内存地址指向系统分配的共享内存地址即可。

## 1.5 SWAP
把暂时不用的内存数据落到磁盘，将内存空间释放出来给需要的进程，达到扩充内存的目的。
Linux 提出 SWAP 的概念，Linux 中可以使用 SWAP 分区，在分配物理内存，但可用内存不足时，将暂时不用的内存数据先放到磁盘上，让有需要的进程先使用，等进程再需要使用这些数据时，再将这些数据加载到内存中，通过这种”交换”技术，Linux 可以让进程使用更多的内存。

## 用户态与内核态

出于安全保护的考量，用户的程序无法直接访问任何硬件设备。像内存条、磁盘、cpu、网卡等等都是硬件设备，而需要委托给内核来执行对设备的访问，此时程序就是进入了内核态。因而内核态与用户态的切换是频繁的，每一次读写文件(磁盘资源)、网络传输(网卡资源)、线程创销(cpu资源)都伴随着用户态/内核态的切换。 

## mmap
memory map
内存映射
将文件磁盘地址映射到进程的虚拟地址空间，应用程序可以通过访问虚拟地址直接访问文件，无需调用内核read/write等系统调用函数，

优点
- 用户直接使用指针的方式写入文件，标记为脏页后自动刷新到磁盘，无须进行文件缓冲区拷贝
- 另外内核对磁盘文件的更新也直接反应到用户空间，实现进程间共享。

## DMA(Direct Memory Access，直接存储器访问)

#### 用户态/内核态切换步骤

- 保留用户态现场（上下文、寄存器、用户栈等）
- 复制用户态参数，用户栈切到内核栈，进入内核态
- 额外的检查（因为内核代码对用户不信任）
- 执行内核态代码
- 复制内核态代码执行结果，回到用户态
- 恢复用户态现场（上下文、寄存器、用户栈等）


## IO模型
### 阻塞式IO （Blocking IO Model）
当请求的IO资源暂时没有就绪是，进程会一直阻塞至资源就绪.
process -> system call read() / recvfrom() -> kernel -> /* block util ready */ -> hardware(disk / memory)
read() 文件系统数据，本地文件IO
recvfrom() socket, 网络IO
简单易用，使用并发数不高、连接数较少的场景。

### 非阻塞式Non-Blocking IO Model
当请求的IO资源暂时没有就绪时，进程不会进入睡眠状态，而是直接返回错误，需要进程反复调用recvfrom/read直至成功返回。反复轮询会导致CPU占用率飙高，在数据收发不均，等待随机性强的场景适用。

###  多路IO复用 IO Multiplexing
system call向内核（kernel）发送需要的文件描述符（fd）和socket，内核监测，当其中一个或者多个就绪时，通知进程进行操作。相对比非阻塞式IO复用，只需要一个监测线程，不需要另起和维护其他进程，减少了资源占用，监测的操作在内核中进行，相对用户进程效率要高。
同时监听多个文件句柄，当某个句柄ready时，通知进程进行处理

**select** 句柄有最大处理上限（1024），使用数组存储待处理句柄 
进程能处理的最大文件描述符上限1024.
文件描述符：
file descriptor, 
linux 文件分类：普通文件，目录文件，链接文件和设备文件
```
int select(
  int nfds, fd_set *readfds, fd_set *writefds,
  fd_set *exceptfds, struct timeval *timeout
);
```
system call select处理流程
1、 程序阻塞等待kernel响应
2、select返回就绪的fd数量
3、进程轮询发现fd
4、发起真正的IO操作
优点：
1、系统支持性较高
2、支持一次监听多个fd
缺点：
1、每个fd_set的大小，受限于FD_SETSIZE(默认的1024)
2、kernel返回后需要轮询所有的fd，数量越大，效率越差

poll
自定义数据结构pollfd，可以出超出1024个文件描述符
但是实际处理也受进程可处理最大描述符限制
```
int poll(struct pollfd *fds, nfds_t nfds, int timeout);

//pollfd结构体如下
struct pollfd {
  int   fd;         /* file descriptor */
  short events;     /* requested events */
  short revents;    /* returned events */
};
```
system call select处理流程
与select类似，使用链表保存句柄，无最大句柄处理上限，


epoll 事件IO通知机制，当处理大量的请求连接时，更加高效。无最大句柄处理上限，使用红黑树保存句柄
快速定位到查询文件描述符是否可读/写
epoll_create 创建一个epoll实例
```
#include <sys/epoll.h>
int epoll_create(int size);
```
创建一个epoll实例并返回它的fd

epoll_ctl
```
#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```
操作epoll实例注册，可往里面新增、删除fd。
op参数是operation的缩写，可为EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL
event即要注册的事件集合(可读、可写之类的)


epoll_wait
```
#include <sys/epoll.h>
int epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout);
int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask)
```
调用时会阻塞至一个或者多个fd就绪，或者timeout，就绪的fd会添加在events

## 信号IO（Signal IU）
system call 不会阻塞进程，当请求的数据就绪时，kernel会发送一个信号给进程，进程发起真正的IO操作

### 异步IO （Asynchronous IO）
异步I/O，即I/O操作不会引起进程阻塞。发起aio_read请求后，kernel会直接返回。等数据就绪，发送一个signal到process处理数据

## 一、常见OS指标

### Load 
**load average **，在特定时间间隔中运行队列中的平均进程数，load1、load5和load15分别对应top命令中load average后的三个值，分别表示最近1分钟、5分钟和15分钟的load。

### CPU Util
CPU利用率，比如60s内cpu只运转了20s，那么cpu利用率时1/3

### 内存使用率
使用的内存空间大小占总的内存空间大小的比例，70%以下为佳

### 磁盘使用率
写满的系统磁盘空间占总的系统磁盘空间大小的比例，70%以下为佳

## 进程
进程是系统资源分配的最小单位，有就绪、运行、阻塞三个状态，就绪时等待CPU时间片的分配，分配到之后进入运行状态，等待资源或者某操作的时间处于阻塞状态。

### 进程种类
- 用户进程，运行在用户态，随着用户的退出而退出的进程
- 守护进程，一直在后台执行，不随用户操作而退出的进程；例如GC垃圾回收器、Tomcat进程、心跳检测等等
- 内核进程，运行在内核态，拥有和系统资源直接交互权限的进程

### 调度算法
- 先来先服务
- 最短调度优先

### 僵尸进程


